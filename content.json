[{"title":"python 学习笔记（一）","date":"2017-06-06T13:57:21.000Z","path":"2017/06/06/python-学习笔记（一）/","text":"一、 python的数据结构1. hashmap -&gt; dict dict = {&quot;red&quot;: 1, &quot;green&quot;: 2, &quot;blue&quot;: 3} dict.get(&quot;red&quot;) 返回1，若没有则返回None dict.pop(&quot;red&quot;) 删除&quot;red&quot; for value in dict.values() 获取所有的value, key不用获取直接用key in dict for k, v in dict.items() 获取所有的键值对 2. array -&gt; list 注：字符串也是数组 list = [&quot;ww&quot;, &quot;qq&quot;, &quot;ee&quot;, &quot;rr&quot;] list.append(&quot;dd&quot;) list.insert(index, value) list.pop(index) 默认删除尾部元素 3. set -&gt; set c_set = set() c_set.add(&quot;www&quot;) c_set.add(&quot;eee&quot;) c_set.remove(&quot;www&quot;) 二、 分支结构 注注注：python所有的分支结构后面都要加 冒号1. if...else a=2 if a&gt;0: print 1 elif a==0: print 0 else : print -1 2. for循环 for value in list: print value sum = 0 for value in range(1, 11): sum += value print sum 3. while循环 i = 1 while i &lt; 10: i += 1 if i % 2 =0: print i while i &gt; 1: i -= 1 if i % 5 == 0: break # continue print i 字符串 str=’AbcdefG’ len(str) # 7 输出字符串，字典，set的长度 str[2: 5] # cde 起始位置和结束位置 str.lower() # abcdefg 转为小写 三、 python高级特性 切片 迭代 isinstance([1,2], Iterable) 判断是否可迭代 for index, val in enumerate([1,2,3]) enumerate()将list变成索引-元素对 列表生成式 [x*y for x in [1,2,3] for y in [-1,-2,-3] if x%2 == 1] 生成器(generator.py) 将列表生成式的[]改为() g = (x*x for x in range(1, 10)) next(g) 获取生成器的下一个元素 for n in g 注： 在函数中使用yield，函数就变成了生成器； 函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 迭代器 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数 把Iterator变成list可以使用list(iterator) 四、 python函数式编程 高阶函数(mrfs.py) map(fn, iterable) reduce(fn, iterable) filter(fn, iterable) Iterator经过filter后会变成Iterable sorted(iterable, key=xx, reverse=True) 返回函数 匿名函数 lambda x: x*x 装饰器(decorator.py) 偏函数 functools.partial(func, **kw) 五、 错误、调试和测试 异常处理 try .. except … finally logging.exception(e) #打印异常堆栈 raise ValueError(“xxxx”) #抛出异常 except Exception as e: #捕获异常 1234567891011121314try: b = 3 / 0except Exception, e: print Exception, \":\", etry: print \"1111\" fh = open(\"testfile\", \"r\") print \"2222\"except IOError, e: print \"3333:\", eelse: print \"4444\" fh.close() 调试 断言 assert assert n != 0, “n is zero” 启动Python解释器时可以用-O参数来关闭assert logging import logging 设置logging的级别,级别低的会覆盖级别高的 logging.basicConfig(level=logging.INFO) debug(4) info(3) waring(2) error(1) 六、 python IO 文件读写 f = open(“fileName”, ‘r’) with open(‘fileName’, ‘r’) as f: #会自动关闭文件 StringIO 内存中读写str from io import StringIO f = StringIO() 或 StringIO(“hello”) f.write(“xxx”) f.getvalue() s = f.readline() BytesIO 内存中读写bytes from io import BytesIO f = BytesIO() f.write(‘中文’.encode(‘utf-8’)) 操作文件 import os os.name #操作系统类型 os.uname() #详细的系统信息，可以调用uname()函数 os.environ #在操作系统中定义的环境变量 os.path.abspath(‘.’) # 查看当前目录的绝对路径 os.path.join(‘/Users/michael’, ‘testdir’) # 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来 os.path.append(‘’) os.mkdir(‘/Users/michael/testdir’) os.rmdir(‘/Users/michael/testdir’) os.path.split(‘/Users/testdir/file.txt’) #把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名(‘/Users/michael/testdir’, ‘file.txt’) os.path.splitext()可以直接让你得到文件扩展名 os.rename(‘test.txt’, ‘test.py’) os.remove(‘test.py’) shutil模块提供了copyfile()的函数,还可以在shutil模块中找到很多实用函数 os.listdir(‘.’) os.path.isdir(fd_name) os.path.isfile(x) 序列化 pickle模块 import pickle pickle.dumps(obj)方法把任意对象序列化成一个bytes pickle.dump(obj, file)直接把对象序列化后写入一个file-like Object pickle.loads(bytes)方法反序列化出对象 pickle.load(file) 从一个file-like Object中直接反序列化出对象 JSON import json json.dumps(obj)方法把任意对象转化为标准json字符串 json.dump(obj, file) json.loads(json_str) json.load(file) json.dumps(obj, default=lambda obj:obj.dict) 将class对象序列化（含slots不可） json.loads(json_str, object_hook=dict2student) 将json字符串转为class对象 python模块 七、 python面向对象编程 slots = (‘name’, ‘age’) 限制动态地绑定属性，但是对子类无效 len(self) 方法我们也知道是为了能让class作用于len()函数 str(self) print对象s时，会自动调用str(s) repr(self) 直接打s，会调用repr(s)输出s的地址，用于调试 iter(self),next(self) 如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个iter()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环 getitem(self, n) 让对象向数组一样可以通过下标取值；对切片对象slice要单独做判断 getattr(self, attr) 只有当调用的属性不存在时，才会调用该方法来尝试获得属性 call(self) 对象实例s，调用s()时会自动调用call方法；判断一个对象是否能被调用即有无call，callable(Student()) @property 相当于@attr.getter @attr.setter 枚举类型（enum.py） name123456789if __name__ == \"__main__\": # 当该模块杯其他模块引用时，以下代码不会执行 module = sys.modules[__name__] # 获取系统中的模块，这里是该模块自身，即文件名去掉后缀 # 每个模块都有一个隐藏的__name__属性即模块名，在模块自身__name__=__main__，表示当前模块是主模块；当该模块被引用时，__name__为文件名去掉后缀 func = getattr(module, sys.argv[1]) # 得到当前模块中名为sys.argv[1]的属性，这里sys.argv[1]=mapper_func，其实是得到mapper_func函数指针（即反射技术） # sys.argv[]是从程序外部获取参数的方法，例如：执行python aaa.py a b c ; sys.argv[0]=aaa.py,sys.argv[1]=a等 args = None # 定义参数元组变量名 if len(sys.argv) &gt; 1: # 当从程序外部获取参数个数大于两个，进入if args = sys.argv[2:] # 获得第三个及后面的参数 func(*args) # 执行func函数即mapper_func()，*args表示参数为可变参数args 导入moduleimport math import random print math.pow(2,3) # 8 print math.floor(4.9) # 4.0 print round(4.9) # 5.0 items = [1,2,3,4,5,6] random.shuffle(items) sam = random.sample(items, 3) # 随机抽样 3个 print items # 3,2,4,1,5,6 print sam a = random.randint(0, 3) # 0-3间的随机数","tags":[]},{"title":"firstPage","date":"2017-03-21T13:07:15.000Z","path":"2017/03/21/firstPage/","text":"第一篇博文今天用hexo搭了个博客，很简单的东东，但是还是花了很久，很伤。 以后可以在自己的博客里写点东西，很开心。慢慢把博客做完整 ^_^ 这是个空链接","tags":[]},{"title":"Hello World","date":"2017-03-21T09:54:04.743Z","path":"2017/03/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]